<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Multithreading | Self Study</title>
    <meta name="generator" content="VuePress 1.5.4">
    
    <meta name="description" content="">
    <link rel="preload" href="/assets/css/0.styles.168efa49.css" as="style"><link rel="preload" href="/assets/js/app.36d4b3ff.js" as="script"><link rel="preload" href="/assets/js/2.ac6f8352.js" as="script"><link rel="preload" href="/assets/js/3.81c00a93.js" as="script"><link rel="prefetch" href="/assets/js/10.fc3bbda0.js"><link rel="prefetch" href="/assets/js/100.2836d11b.js"><link rel="prefetch" href="/assets/js/101.a656cbcd.js"><link rel="prefetch" href="/assets/js/102.409ac812.js"><link rel="prefetch" href="/assets/js/103.ed33ff2e.js"><link rel="prefetch" href="/assets/js/104.960aaecb.js"><link rel="prefetch" href="/assets/js/105.c0fd7edc.js"><link rel="prefetch" href="/assets/js/106.e84ee637.js"><link rel="prefetch" href="/assets/js/107.f49ffeac.js"><link rel="prefetch" href="/assets/js/108.32c2170f.js"><link rel="prefetch" href="/assets/js/109.2493935f.js"><link rel="prefetch" href="/assets/js/11.80bbe465.js"><link rel="prefetch" href="/assets/js/110.c9ca2a79.js"><link rel="prefetch" href="/assets/js/111.9d37c1d2.js"><link rel="prefetch" href="/assets/js/112.273e6cbb.js"><link rel="prefetch" href="/assets/js/113.7afa7aa6.js"><link rel="prefetch" href="/assets/js/114.17b37a46.js"><link rel="prefetch" href="/assets/js/115.0352e12b.js"><link rel="prefetch" href="/assets/js/116.f156995d.js"><link rel="prefetch" href="/assets/js/117.f5676ab9.js"><link rel="prefetch" href="/assets/js/118.54e71879.js"><link rel="prefetch" href="/assets/js/119.6596ab1b.js"><link rel="prefetch" href="/assets/js/12.90093a1b.js"><link rel="prefetch" href="/assets/js/120.38326801.js"><link rel="prefetch" href="/assets/js/121.08eb006e.js"><link rel="prefetch" href="/assets/js/122.86482a2b.js"><link rel="prefetch" href="/assets/js/123.a8e0a08e.js"><link rel="prefetch" href="/assets/js/124.fbf9392f.js"><link rel="prefetch" href="/assets/js/125.6d97864a.js"><link rel="prefetch" href="/assets/js/126.b74c11a5.js"><link rel="prefetch" href="/assets/js/13.35dad34e.js"><link rel="prefetch" href="/assets/js/14.4c12ba75.js"><link rel="prefetch" href="/assets/js/15.5ad1d0a8.js"><link rel="prefetch" href="/assets/js/16.9016882d.js"><link rel="prefetch" href="/assets/js/17.241510cf.js"><link rel="prefetch" href="/assets/js/18.2d3076aa.js"><link rel="prefetch" href="/assets/js/19.daa2cf74.js"><link rel="prefetch" href="/assets/js/20.7e6028b9.js"><link rel="prefetch" href="/assets/js/21.5c651d60.js"><link rel="prefetch" href="/assets/js/22.b70adde0.js"><link rel="prefetch" href="/assets/js/23.c9fedc59.js"><link rel="prefetch" href="/assets/js/24.60d8e7ad.js"><link rel="prefetch" href="/assets/js/25.0c3959cc.js"><link rel="prefetch" href="/assets/js/26.4c24d23a.js"><link rel="prefetch" href="/assets/js/27.2f8c8240.js"><link rel="prefetch" href="/assets/js/28.5568c70d.js"><link rel="prefetch" href="/assets/js/29.5878b10b.js"><link rel="prefetch" href="/assets/js/30.a99a448f.js"><link rel="prefetch" href="/assets/js/31.5c896b2e.js"><link rel="prefetch" href="/assets/js/32.4f871e23.js"><link rel="prefetch" href="/assets/js/33.c812fe8f.js"><link rel="prefetch" href="/assets/js/34.6acd62fa.js"><link rel="prefetch" href="/assets/js/35.f652a316.js"><link rel="prefetch" href="/assets/js/36.5d2172eb.js"><link rel="prefetch" href="/assets/js/37.f5f0ff49.js"><link rel="prefetch" href="/assets/js/38.ca5c8d85.js"><link rel="prefetch" href="/assets/js/39.43d8a8f3.js"><link rel="prefetch" href="/assets/js/4.323ab50c.js"><link rel="prefetch" href="/assets/js/40.0750890b.js"><link rel="prefetch" href="/assets/js/41.69bf1ddc.js"><link rel="prefetch" href="/assets/js/42.025c3e14.js"><link rel="prefetch" href="/assets/js/43.9937be17.js"><link rel="prefetch" href="/assets/js/44.0486b188.js"><link rel="prefetch" href="/assets/js/45.7e6f5b11.js"><link rel="prefetch" href="/assets/js/46.ad154e1b.js"><link rel="prefetch" href="/assets/js/47.0476fbee.js"><link rel="prefetch" href="/assets/js/48.a4205cb1.js"><link rel="prefetch" href="/assets/js/49.cb5ebdc5.js"><link rel="prefetch" href="/assets/js/5.c7e616d1.js"><link rel="prefetch" href="/assets/js/50.7116a913.js"><link rel="prefetch" href="/assets/js/51.b1caf5d3.js"><link rel="prefetch" href="/assets/js/52.d6122ef5.js"><link rel="prefetch" href="/assets/js/53.6cdbdf4e.js"><link rel="prefetch" href="/assets/js/54.eee92ec8.js"><link rel="prefetch" href="/assets/js/55.fe8825ab.js"><link rel="prefetch" href="/assets/js/56.ae76234b.js"><link rel="prefetch" href="/assets/js/57.3776658d.js"><link rel="prefetch" href="/assets/js/58.a3ce6905.js"><link rel="prefetch" href="/assets/js/59.3d961c4a.js"><link rel="prefetch" href="/assets/js/6.16b31894.js"><link rel="prefetch" href="/assets/js/60.74aa4cd4.js"><link rel="prefetch" href="/assets/js/61.d1a78130.js"><link rel="prefetch" href="/assets/js/62.271ea18b.js"><link rel="prefetch" href="/assets/js/63.ff98536b.js"><link rel="prefetch" href="/assets/js/64.6a3f1e09.js"><link rel="prefetch" href="/assets/js/65.ed93e065.js"><link rel="prefetch" href="/assets/js/66.2c580e1e.js"><link rel="prefetch" href="/assets/js/67.1ab2d0c1.js"><link rel="prefetch" href="/assets/js/68.e0666507.js"><link rel="prefetch" href="/assets/js/69.fda9b9ff.js"><link rel="prefetch" href="/assets/js/7.07539e81.js"><link rel="prefetch" href="/assets/js/70.a76c8845.js"><link rel="prefetch" href="/assets/js/71.c6b1276a.js"><link rel="prefetch" href="/assets/js/72.5a2eabb9.js"><link rel="prefetch" href="/assets/js/73.eb66f52d.js"><link rel="prefetch" href="/assets/js/74.b7458b07.js"><link rel="prefetch" href="/assets/js/75.5cba2351.js"><link rel="prefetch" href="/assets/js/76.0d1792db.js"><link rel="prefetch" href="/assets/js/77.9e2495ed.js"><link rel="prefetch" href="/assets/js/78.1fb3b0ef.js"><link rel="prefetch" href="/assets/js/79.d5624f8f.js"><link rel="prefetch" href="/assets/js/8.ab33dfe3.js"><link rel="prefetch" href="/assets/js/80.41988336.js"><link rel="prefetch" href="/assets/js/81.e04bd79e.js"><link rel="prefetch" href="/assets/js/82.7698341f.js"><link rel="prefetch" href="/assets/js/83.1c34abab.js"><link rel="prefetch" href="/assets/js/84.412a7610.js"><link rel="prefetch" href="/assets/js/85.db7b7261.js"><link rel="prefetch" href="/assets/js/86.b2c22b42.js"><link rel="prefetch" href="/assets/js/87.6aa34b5d.js"><link rel="prefetch" href="/assets/js/88.9f6b1695.js"><link rel="prefetch" href="/assets/js/89.2e861ca5.js"><link rel="prefetch" href="/assets/js/9.dcd19ef1.js"><link rel="prefetch" href="/assets/js/90.eda5d2de.js"><link rel="prefetch" href="/assets/js/91.b9660e21.js"><link rel="prefetch" href="/assets/js/92.3e4fac30.js"><link rel="prefetch" href="/assets/js/93.d895800c.js"><link rel="prefetch" href="/assets/js/94.cf82f46d.js"><link rel="prefetch" href="/assets/js/95.ccbe7042.js"><link rel="prefetch" href="/assets/js/96.a2c2339e.js"><link rel="prefetch" href="/assets/js/97.1728e0a4.js"><link rel="prefetch" href="/assets/js/98.e0f4449b.js"><link rel="prefetch" href="/assets/js/99.1e34949c.js">
    <link rel="stylesheet" href="/assets/css/0.styles.168efa49.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Self Study</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Algorithm" class="dropdown-title"><span class="title">Algorithm</span> <span class="arrow down"></span></button> <button type="button" aria-label="Algorithm" class="mobile-dropdown-title"><span class="title">Algorithm</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Algorithm/DataStructure/" class="nav-link">
  DataStructure
</a></li><li class="dropdown-item"><!----> <a href="/Algorithm/Leetcode/" class="nav-link">
  Leetcode
</a></li><li class="dropdown-item"><!----> <a href="/Algorithm/Algorithm/" class="nav-link">
  Algorithm
</a></li><li class="dropdown-item"><!----> <a href="/Algorithm/Math/" class="nav-link">
  Math
</a></li><li class="dropdown-item"><!----> <a href="/Algorithm/OperatingSystem/" class="nav-link">
  OperatingSystem
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Interview" class="dropdown-title"><span class="title">Interview</span> <span class="arrow down"></span></button> <button type="button" aria-label="Interview" class="mobile-dropdown-title"><span class="title">Interview</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Interview/Core/" class="nav-link">
  Core
</a></li><li class="dropdown-item"><!----> <a href="/Interview/Designpattern/" class="nav-link">
  Designpattern
</a></li><li class="dropdown-item"><!----> <a href="/Interview/Senario/" class="nav-link">
  Senario
</a></li><li class="dropdown-item"><!----> <a href="/Interview/SourceCode/" class="nav-link">
  SourceCode
</a></li><li class="dropdown-item"><!----> <a href="/Interview/Systemdesign/" class="nav-link">
  Systemdesign
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Projects" class="dropdown-title"><span class="title">Projects</span> <span class="arrow down"></span></button> <button type="button" aria-label="Projects" class="mobile-dropdown-title"><span class="title">Projects</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Projects/webdesign/" class="nav-link">
  webdesign
</a></li><li class="dropdown-item"><!----> <a href="/Projects/xiaochengxu/" class="nav-link">
  xiaochengxu
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Usefull-tips" class="dropdown-title"><span class="title">Usefull-tips</span> <span class="arrow down"></span></button> <button type="button" aria-label="Usefull-tips" class="mobile-dropdown-title"><span class="title">Usefull-tips</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Usefull-tips/chrome/" class="nav-link">
  chrome
</a></li><li class="dropdown-item"><!----> <a href="/Usefull-tips/git/" class="nav-link">
  git
</a></li><li class="dropdown-item"><!----> <a href="/Usefull-tips/mac/" class="nav-link">
  mac
</a></li><li class="dropdown-item"><!----> <a href="/Usefull-tips/python/" class="nav-link">
  python
</a></li><li class="dropdown-item"><!----> <a href="/Usefull-tips/vscode/" class="nav-link">
  vscode
</a></li><li class="dropdown-item"><!----> <a href="/Usefull-tips/intellij/" class="nav-link">
  intellij
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="back-end" class="dropdown-title"><span class="title">back-end</span> <span class="arrow down"></span></button> <button type="button" aria-label="back-end" class="mobile-dropdown-title"><span class="title">back-end</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/back-end/Java/" class="nav-link router-link-active">
  Java
</a></li><li class="dropdown-item"><!----> <a href="/back-end/Python/" class="nav-link">
  Python
</a></li><li class="dropdown-item"><!----> <a href="/back-end/Spring/" class="nav-link">
  Spring
</a></li><li class="dropdown-item"><!----> <a href="/back-end/nodejs/" class="nav-link">
  nodejs
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="front-end" class="dropdown-title"><span class="title">front-end</span> <span class="arrow down"></span></button> <button type="button" aria-label="front-end" class="mobile-dropdown-title"><span class="title">front-end</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/front-end/Zepto/" class="nav-link">
  Zepto
</a></li><li class="dropdown-item"><!----> <a href="/front-end/CSS/" class="nav-link">
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/front-end/ES6/" class="nav-link">
  ES6
</a></li><li class="dropdown-item"><!----> <a href="/front-end/HTML/" class="nav-link">
  HTML
</a></li><li class="dropdown-item"><!----> <a href="/front-end/Javascript/" class="nav-link">
  Javascript
</a></li><li class="dropdown-item"><!----> <a href="/front-end/Typescript/" class="nav-link">
  Typescript
</a></li><li class="dropdown-item"><!----> <a href="/front-end/Vue/" class="nav-link">
  Vue
</a></li><li class="dropdown-item"><!----> <a href="/front-end/Webpack/" class="nav-link">
  Webpack
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Algorithm" class="dropdown-title"><span class="title">Algorithm</span> <span class="arrow down"></span></button> <button type="button" aria-label="Algorithm" class="mobile-dropdown-title"><span class="title">Algorithm</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Algorithm/DataStructure/" class="nav-link">
  DataStructure
</a></li><li class="dropdown-item"><!----> <a href="/Algorithm/Leetcode/" class="nav-link">
  Leetcode
</a></li><li class="dropdown-item"><!----> <a href="/Algorithm/Algorithm/" class="nav-link">
  Algorithm
</a></li><li class="dropdown-item"><!----> <a href="/Algorithm/Math/" class="nav-link">
  Math
</a></li><li class="dropdown-item"><!----> <a href="/Algorithm/OperatingSystem/" class="nav-link">
  OperatingSystem
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Interview" class="dropdown-title"><span class="title">Interview</span> <span class="arrow down"></span></button> <button type="button" aria-label="Interview" class="mobile-dropdown-title"><span class="title">Interview</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Interview/Core/" class="nav-link">
  Core
</a></li><li class="dropdown-item"><!----> <a href="/Interview/Designpattern/" class="nav-link">
  Designpattern
</a></li><li class="dropdown-item"><!----> <a href="/Interview/Senario/" class="nav-link">
  Senario
</a></li><li class="dropdown-item"><!----> <a href="/Interview/SourceCode/" class="nav-link">
  SourceCode
</a></li><li class="dropdown-item"><!----> <a href="/Interview/Systemdesign/" class="nav-link">
  Systemdesign
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Projects" class="dropdown-title"><span class="title">Projects</span> <span class="arrow down"></span></button> <button type="button" aria-label="Projects" class="mobile-dropdown-title"><span class="title">Projects</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Projects/webdesign/" class="nav-link">
  webdesign
</a></li><li class="dropdown-item"><!----> <a href="/Projects/xiaochengxu/" class="nav-link">
  xiaochengxu
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Usefull-tips" class="dropdown-title"><span class="title">Usefull-tips</span> <span class="arrow down"></span></button> <button type="button" aria-label="Usefull-tips" class="mobile-dropdown-title"><span class="title">Usefull-tips</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Usefull-tips/chrome/" class="nav-link">
  chrome
</a></li><li class="dropdown-item"><!----> <a href="/Usefull-tips/git/" class="nav-link">
  git
</a></li><li class="dropdown-item"><!----> <a href="/Usefull-tips/mac/" class="nav-link">
  mac
</a></li><li class="dropdown-item"><!----> <a href="/Usefull-tips/python/" class="nav-link">
  python
</a></li><li class="dropdown-item"><!----> <a href="/Usefull-tips/vscode/" class="nav-link">
  vscode
</a></li><li class="dropdown-item"><!----> <a href="/Usefull-tips/intellij/" class="nav-link">
  intellij
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="back-end" class="dropdown-title"><span class="title">back-end</span> <span class="arrow down"></span></button> <button type="button" aria-label="back-end" class="mobile-dropdown-title"><span class="title">back-end</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/back-end/Java/" class="nav-link router-link-active">
  Java
</a></li><li class="dropdown-item"><!----> <a href="/back-end/Python/" class="nav-link">
  Python
</a></li><li class="dropdown-item"><!----> <a href="/back-end/Spring/" class="nav-link">
  Spring
</a></li><li class="dropdown-item"><!----> <a href="/back-end/nodejs/" class="nav-link">
  nodejs
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="front-end" class="dropdown-title"><span class="title">front-end</span> <span class="arrow down"></span></button> <button type="button" aria-label="front-end" class="mobile-dropdown-title"><span class="title">front-end</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/front-end/Zepto/" class="nav-link">
  Zepto
</a></li><li class="dropdown-item"><!----> <a href="/front-end/CSS/" class="nav-link">
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/front-end/ES6/" class="nav-link">
  ES6
</a></li><li class="dropdown-item"><!----> <a href="/front-end/HTML/" class="nav-link">
  HTML
</a></li><li class="dropdown-item"><!----> <a href="/front-end/Javascript/" class="nav-link">
  Javascript
</a></li><li class="dropdown-item"><!----> <a href="/front-end/Typescript/" class="nav-link">
  Typescript
</a></li><li class="dropdown-item"><!----> <a href="/front-end/Vue/" class="nav-link">
  Vue
</a></li><li class="dropdown-item"><!----> <a href="/front-end/Webpack/" class="nav-link">
  Webpack
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/back-end/Java/" aria-current="page" class="sidebar-link">Intro</a></li><li><a href="/back-end/Java/1-JVM.html" class="sidebar-link">JVM</a></li><li><a href="/back-end/Java/2-variables.html" class="sidebar-link">常量和变量</a></li><li><a href="/back-end/Java/3-Loop-array-method.html" class="sidebar-link">Loop array and Method</a></li><li><a href="/back-end/Java/4-class.html" class="sidebar-link">Class and object</a></li><li><a href="/back-end/Java/Collection.html" class="sidebar-link">Collection</a></li><li><a href="/back-end/Java/Interface.html" class="sidebar-link">Interface</a></li><li><a href="/back-end/Java/Java8.html" class="sidebar-link">Java8</a></li><li><a href="/back-end/Java/Multithreading.html" aria-current="page" class="active sidebar-link">Multithreading</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/back-end/Java/Multithreading.html#_1-java-如何编写多线程" class="sidebar-link">1. Java 如何编写多线程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/back-end/Java/Multithreading.html#_1-1-java-实现多线程的方式" class="sidebar-link">1.1 Java 实现多线程的方式</a></li><li class="sidebar-sub-header"><a href="/back-end/Java/Multithreading.html#_1-2-单线程实现单词抄写" class="sidebar-link">1.2 单线程实现单词抄写</a></li><li class="sidebar-sub-header"><a href="/back-end/Java/Multithreading.html#_1-3-继承-thread-实现独立线程单词抄写" class="sidebar-link">1.3 继承 Thread 实现独立线程单词抄写</a></li><li class="sidebar-sub-header"><a href="/back-end/Java/Multithreading.html#_1-4-多线程并发实现单词抄写" class="sidebar-link">1.4 多线程并发实现单词抄写</a></li><li class="sidebar-sub-header"><a href="/back-end/Java/Multithreading.html#_1-5-实现-runnable-接口-启用单独线程抄写单词" class="sidebar-link">1.5 实现 Runnable 接口，启用单独线程抄写单词</a></li></ul></li><li class="sidebar-sub-header"><a href="/back-end/Java/Multithreading.html#_2-并发可能会遇到的问题" class="sidebar-link">2. 并发可能会遇到的问题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/back-end/Java/Multithreading.html#_2-1-并发抄写单词问题分析" class="sidebar-link">2.1 并发抄写单词问题分析</a></li><li class="sidebar-sub-header"><a href="/back-end/Java/Multithreading.html#_2-2-尝试解决并发问题" class="sidebar-link">2.2 尝试解决并发问题</a></li><li class="sidebar-sub-header"><a href="/back-end/Java/Multithreading.html#_2-3-线程安全" class="sidebar-link">2.3 线程安全</a></li><li class="sidebar-sub-header"><a href="/back-end/Java/Multithreading.html#_2-4-多线程相关概念" class="sidebar-link">2.4 多线程相关概念</a></li></ul></li><li class="sidebar-sub-header"><a href="/back-end/Java/Multithreading.html#_3-thread-vs-runnable" class="sidebar-link">3. Thread vs Runnable</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/back-end/Java/Multithreading.html#_3-1-thread-start方法源代码分析" class="sidebar-link">3.1 Thread start方法源代码分析</a></li></ul></li><li class="sidebar-sub-header"><a href="/back-end/Java/Multithreading.html#_31-凭票取餐-future模式详解" class="sidebar-link">31 凭票取餐—Future模式详解</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/back-end/Java/Multithreading.html#_31-1-future-模式介绍" class="sidebar-link">31.1 Future 模式介绍</a></li><li class="sidebar-sub-header"><a href="/back-end/Java/Multithreading.html#_31-2-future-使用" class="sidebar-link">31.2 Future 使用</a></li><li class="sidebar-sub-header"><a href="/back-end/Java/Multithreading.html#_31-3-future-源码解析" class="sidebar-link">31.3 Future 源码解析</a></li></ul></li><li class="sidebar-sub-header"><a href="/back-end/Java/Multithreading.html#_34-completablefuture" class="sidebar-link">34 CompletableFuture</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/back-end/Java/Multithreading.html#_34-1-completablefuture-起源" class="sidebar-link">34.1 CompletableFuture 起源</a></li><li class="sidebar-sub-header"><a href="/back-end/Java/Multithreading.html#_34-2-completablefuture-介绍" class="sidebar-link">34.2 CompletableFuture 介绍</a></li></ul></li></ul></li><li><a href="/back-end/Java/String.html" class="sidebar-link">String</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="multithreading"><a href="#multithreading" class="header-anchor">#</a> Multithreading</h1> <h2 id="_1-java-如何编写多线程"><a href="#_1-java-如何编写多线程" class="header-anchor">#</a> 1. Java 如何编写多线程</h2> <h3 id="_1-1-java-实现多线程的方式"><a href="#_1-1-java-实现多线程的方式" class="header-anchor">#</a> 1.1 Java 实现多线程的方式</h3> <p>在 java 中实现多线程有四种方式，如下：</p> <ul><li>继承 Thread 类</li> <li>实现 Runnable 接口</li> <li>使用 FutureTask</li> <li>使用 Executor 框架</li></ul> <p>其中继承 Thread 类和实现 Runnable 接口是最基本的方式，但有一个共同的缺点 ---- 没有返回值。而 FutureTask 则解决了这个问题。 Executor 是 JDK 提供的多线程框架</p> <h4 id="例子"><a href="#例子" class="header-anchor">#</a> 例子</h4> <p>小明是一位学生，今天不太开心。因为昨天英语课学习了一个新的单词，今天考试时他写错了。老师惩罚他抄写 100 遍。这个单词有点长，是什么单词呢？internationalization。看着眼熟吗？做过国际化开发的同学一定认识，这个单词因为太长，在 java 中被称为 i18n，也就是首字母 i 和尾字母 n 之间有 18 个字母。小明很苦恼，怎么能快点写完呢？</p> <h3 id="_1-2-单线程实现单词抄写"><a href="#_1-2-单线程实现单词抄写" class="header-anchor">#</a> 1.2 单线程实现单词抄写</h3> <p>OK，下面我们通过程序来模拟小明抄写单词的任务。我们编写如下几个类：</p> <p>1、Punishment.java</p> <p>存储要抄写的单词，以及剩余的抄写次数。主要代码如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Punishment</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> leftCopyCount<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> wordToCopy<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>2、Student.java</p> <p>持有 Punishment 的引用。实现了抄写单词的 copyWord 方法。主要代码如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">Punishment</span> punishment<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span><span class="token class-name">Punishment</span> punishment<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">=</span>name<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>punishment <span class="token operator">=</span> punishment<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">copyWord</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> threadName <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>punishment<span class="token punctuation">.</span><span class="token function">getLeftCopyCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">int</span> leftCopyCount <span class="token operator">=</span> punishment<span class="token punctuation">.</span><span class="token function">getLeftCopyCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>threadName<span class="token operator">+</span><span class="token string">&quot;线程-&quot;</span><span class="token operator">+</span>name <span class="token operator">+</span> <span class="token string">&quot;抄写&quot;</span> <span class="token operator">+</span> punishment<span class="token punctuation">.</span><span class="token function">getWordToCopy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;。还要抄写&quot;</span> <span class="token operator">+</span> <span class="token operator">--</span>leftCopyCount <span class="token operator">+</span> <span class="token string">&quot;次&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                punishment<span class="token punctuation">.</span><span class="token function">setLeftCopyCount</span><span class="token punctuation">(</span>leftCopyCount<span class="token punctuation">)</span><span class="token punctuation">;</span>
                count<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>threadName<span class="token operator">+</span><span class="token string">&quot;线程-&quot;</span><span class="token operator">+</span>name <span class="token operator">+</span> <span class="token string">&quot;一共抄写了&quot;</span> <span class="token operator">+</span> count <span class="token operator">+</span> <span class="token string">&quot;次！&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Student 构造函数传入 Punishment。copyWord 方法是根据惩罚内容。完成单词抄写的主要逻辑。</p> <p>我们重点看一下 coppyWord 方法。count 变量是计数器，记录抄写的总次数。threadName 是本线程的名称，这里通过 Thread 的静态方法 currentThread 取得当前线程，然后通过 getName 方法获取线程名称。</p> <p>在 while 循环体中，当 punishment 的剩余抄写次数大于 0 时，执行抄写逻辑，否则抄写任务完成，跳出循环。main 方法代码如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StudentClient</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Punishment</span> punishment <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Punishment</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token string">&quot;internationalization&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Student</span> student <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">&quot;小明&quot;</span><span class="token punctuation">,</span>punishment<span class="token punctuation">)</span><span class="token punctuation">;</span>
        student<span class="token punctuation">.</span><span class="token function">copyWord</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在控制台可以清楚地看到小明抄写了 100 次单词。不过此时的代码并没有引入多线程，是单线程小明在工作。唯一看到的和线程沾边的就是日志中的 “main 线程”，这是通过 Thread.currentThread().getName () 获取的当前线程名称，也就是 main 函数所在的线程。</p> <h3 id="_1-3-继承-thread-实现独立线程单词抄写"><a href="#_1-3-继承-thread-实现独立线程单词抄写" class="header-anchor">#</a> 1.3 继承 Thread 实现独立线程单词抄写</h3> <p>接下来我们尝试为小明单独起一个线程做这个事情，而不是在 main 线程中完成。回到我们所讲的主题，实现多线程的方式上，我们先采用继承 thread 类，重写 run 方法的方式。改版后，student 代码如下:</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">//1、继承Thread类</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span><span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">Punishment</span> punishment<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">Punishment</span> punishment<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//2、调用Thread构造方法，设置threadName</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">=</span>name<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>punishment <span class="token operator">=</span> punishment<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">copyWord</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> threadName <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>punishment<span class="token punctuation">.</span><span class="token function">getLeftCopyCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">int</span> leftCopyCount <span class="token operator">=</span> punishment<span class="token punctuation">.</span><span class="token function">getLeftCopyCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>threadName<span class="token operator">+</span><span class="token string">&quot;线程-&quot;</span><span class="token operator">+</span>name <span class="token operator">+</span> <span class="token string">&quot;抄写&quot;</span> <span class="token operator">+</span> punishment<span class="token punctuation">.</span><span class="token function">getWordToCopy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;。还要抄写&quot;</span> <span class="token operator">+</span> <span class="token operator">--</span>leftCopyCount <span class="token operator">+</span> <span class="token string">&quot;次&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                punishment<span class="token punctuation">.</span><span class="token function">setLeftCopyCount</span><span class="token punctuation">(</span>leftCopyCount<span class="token punctuation">)</span><span class="token punctuation">;</span>
                count<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>threadName<span class="token operator">+</span><span class="token string">&quot;线程-&quot;</span><span class="token operator">+</span>name <span class="token operator">+</span> <span class="token string">&quot;一共抄写了&quot;</span> <span class="token operator">+</span> count <span class="token operator">+</span> <span class="token string">&quot;次！&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//3、重写run方法，调用copyWord完成任务</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">copyWord</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>提醒下，在第 2 个点，我们设置了线程的名称，一会在输出中会看到带来的变化。</p> <p>main 方法代码如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StudentClient</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Punishment</span> punishment <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Punishment</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token string">&quot;internationalization&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Student</span> student <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">&quot;小明&quot;</span><span class="token punctuation">,</span>punishment<span class="token punctuation">)</span><span class="token punctuation">;</span>
        student<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以看到此时调用的不是 student 的 copyWord 方法，而是调用了 start 方法。start 方法是从 Thread 类继承而来，调用后线程进入就绪状态，等待 CPU 的调用。而 start 方法最终会触发执行 run 方法，在 run 方法中 copyWord 被执行。输出如下:</p> <div class="language-text extra-class"><pre class="language-text"><code>小明线程-小明抄写internationalization。还要抄写99次
......（中间省略）
小明线程-小明抄写internationalization。还要抄写0次
小明线程-小明一共抄写了100次！
</code></pre></div><p>我们可以看到，现在不再是 main 线程在工作了，而是小明线程。这说明 student 已经工作在 “小明” 线程上。为了更加直观，我们在 student.start () 后面加一行代码:</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Another thread will finish the punishment。 main thread is finished&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>可以看到主线程在 student.start () 后，会立即向下执行。而小明线程则在独立执行 copyWord 方法。这里你可以做个对比，单线程情况下，一定是在小明抄写的所有输出后才会输出 “main thread is finished”。</p> <h3 id="_1-4-多线程并发实现单词抄写"><a href="#_1-4-多线程并发实现单词抄写" class="header-anchor">#</a> 1.4 多线程并发实现单词抄写</h3> <p>你心里一定在想，这个例子没有看到多线程的好处啊？是的，如果仅仅是小明一个人去完成任务，其实和单线程没有区别。但是假如小明找来了几个同学帮他一起写呢？</p> <p>我们在 main 方法中启动多个线程一块完成单词抄写任务</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Punishment</span> punishment <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Punishment</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token string">&quot;internationalization&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">Student</span> xiaoming <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">&quot;小明&quot;</span><span class="token punctuation">,</span>punishment<span class="token punctuation">)</span><span class="token punctuation">;</span>
    xiaoming<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">Student</span> xiaozhang <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">&quot;小张&quot;</span><span class="token punctuation">,</span>punishment<span class="token punctuation">)</span><span class="token punctuation">;</span>
    xiaozhang<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">Student</span> xiao赵 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">&quot;小赵&quot;</span><span class="token punctuation">,</span>punishment<span class="token punctuation">)</span><span class="token punctuation">;</span>
    xiaozhang<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们在控制台可以看到如下输出：</p> <div class="language- extra-class"><pre class="language-text"><code>小赵线程-小赵一共抄写了100次！
小明线程-小明一共抄写了100次！
小张线程-小张一共抄写了100次！
</code></pre></div><h3 id="_1-5-实现-runnable-接口-启用单独线程抄写单词"><a href="#_1-5-实现-runnable-接口-启用单独线程抄写单词" class="header-anchor">#</a> 1.5 实现 Runnable 接口，启用单独线程抄写单词</h3> <p>上面讲解了通过继承 Thread 的方式来实现多线程，接下来我们看看如何以实现 Runnable 接口的形式实现多线程。student 代码改造后如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">Punishment</span> punishment<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">Punishment</span> punishment<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">=</span>name<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>punishment <span class="token operator">=</span> punishment<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">copyWord</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> threadName <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>punishment<span class="token punctuation">.</span><span class="token function">getLeftCopyCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
              <span class="token keyword">int</span> leftCopyCount <span class="token operator">=</span> punishment<span class="token punctuation">.</span><span class="token function">getLeftCopyCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
              <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>threadName<span class="token operator">+</span><span class="token string">&quot;线程-&quot;</span><span class="token operator">+</span>name <span class="token operator">+</span> <span class="token string">&quot;抄写&quot;</span> <span class="token operator">+</span> punishment<span class="token punctuation">.</span><span class="token function">getWordToCopy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;。还要抄写&quot;</span> <span class="token operator">+</span> <span class="token operator">--</span>leftCopyCount <span class="token operator">+</span> <span class="token string">&quot;次&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
              punishment<span class="token punctuation">.</span><span class="token function">setLeftCopyCount</span><span class="token punctuation">(</span>leftCopyCount<span class="token punctuation">)</span><span class="token punctuation">;</span>
              count<span class="token operator">++</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
              <span class="token keyword">break</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>threadName<span class="token operator">+</span><span class="token string">&quot;线程-&quot;</span><span class="token operator">+</span>name <span class="token operator">+</span> <span class="token string">&quot;一共抄写了&quot;</span> <span class="token operator">+</span> count <span class="token operator">+</span> <span class="token string">&quot;次！&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">//重写run方法，完成任务。</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">copyWord</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>和继承 thread 实现多线程的区别，在于现在是实现 runnable 接口。不过也是需要实现 run () 方法。另外由于 runnable 是接口，所以之前构造函数中调用父类构造函数的语句需要去掉。</p> <p>我们再看看 StudentClient 的代码：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StudentClient</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Punishment</span> punishment <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Punishment</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token string">&quot;internationalization&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Thread</span> xiaoming <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">&quot;小明&quot;</span><span class="token punctuation">,</span>punishment<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">&quot;小明&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        xiaoming<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以看到我们需要创建一个 thread，把实现了 runnable 接口的对象通过构造函数传递进去，Thread 构造函数的第二个参数是自定义的 thread name。之前由于 Student 就是 Thread 的子类，所以我们直接通过 new Student 就可以得到线程对象。最后都是通过调用 Thread 对象的 start 方法来启动线程。运行代码后发现输出结果和继承 thread 方式是一模一样的。</p> <h2 id="_2-并发可能会遇到的问题"><a href="#_2-并发可能会遇到的问题" class="header-anchor">#</a> 2. 并发可能会遇到的问题</h2> <h3 id="_2-1-并发抄写单词问题分析"><a href="#_2-1-并发抄写单词问题分析" class="header-anchor">#</a> 2.1 并发抄写单词问题分析</h3> <p>回到抄单词这个问题上，我们试图引入更多的学生来一块完成任务，那么这些学生怎么知道目前抄写多少单词了？自己是否还需要继续抄写呢？我们看相关代码：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>punishment<span class="token punctuation">.</span><span class="token function">getLeftCopyCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> leftCopyCount <span class="token operator">=</span> punishment<span class="token punctuation">.</span><span class="token function">getLeftCopyCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>threadName<span class="token operator">+</span><span class="token string">&quot;线程-&quot;</span><span class="token operator">+</span>name <span class="token operator">+</span> <span class="token string">&quot;抄写&quot;</span> <span class="token operator">+</span> punishment<span class="token punctuation">.</span><span class="token function">getWordToCopy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;。还要抄写&quot;</span> <span class="token operator">+</span> <span class="token operator">--</span>leftCopyCount <span class="token operator">+</span> <span class="token string">&quot;次&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    punishment<span class="token punctuation">.</span><span class="token function">setLeftCopyCount</span><span class="token punctuation">(</span>leftCopyCount<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我用通俗的方式来说明这段代码的逻辑。为了让参与抄写单词的学生知道剩余抄写的数量，我们找来了一块小黑板，然后把剩余的总量写在上面，每个学生抄写之前先看一眼黑板，如果剩余的数量大于零，那么还需要继续抄写，抄写完后，擦掉黑板上的数字，把剩余数量-1，写上去。</p> <p>OK，一个人按照这个流程抄写是没问题的，但是多个人同时抄写，问题就多了。</p> <ol><li>读取次数和抄完更新次数之间有时间间隔，此时别的学生也会读到同样的剩余次数，那么这次抄写就是多余的；</li> <li>在更新leftCopyCount的时候，可能其它多个线程已经更新过了，也就是说此时leftCopyCount并不是你当初取出来的值，那么可能会把剩余数量更新的比此时还要大。这样其它线程的抄写就白做了。因为剩余数量被更新了回去。</li></ol> <h3 id="_2-2-尝试解决并发问题"><a href="#_2-2-尝试解决并发问题" class="header-anchor">#</a> 2.2 尝试解决并发问题</h3> <p>为了解决这两个问题我们修改copyWord方法代码如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">copyWord</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token class-name">String</span> threadName <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>punishment<span class="token punctuation">.</span><span class="token function">getLeftCopyCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> leftCopyCount <span class="token operator">=</span> punishment<span class="token punctuation">.</span><span class="token function">getLeftCopyCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            leftCopyCount<span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>leftCopyCount<span class="token operator">&lt;</span>punishment<span class="token punctuation">.</span><span class="token function">getLeftCopyCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                punishment<span class="token punctuation">.</span><span class="token function">setLeftCopyCount</span><span class="token punctuation">(</span>leftCopyCount<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>threadName<span class="token operator">+</span><span class="token string">&quot;线程-&quot;</span><span class="token operator">+</span>name <span class="token operator">+</span> <span class="token string">&quot;抄写&quot;</span> <span class="token operator">+</span> punishment<span class="token punctuation">.</span><span class="token function">getWordToCopy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;。还要抄写&quot;</span> <span class="token operator">+</span> leftCopyCount <span class="token operator">+</span> <span class="token string">&quot;次&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            count<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>threadName<span class="token operator">+</span><span class="token string">&quot;线程-&quot;</span><span class="token operator">+</span>name <span class="token operator">+</span> <span class="token string">&quot;一共抄写了&quot;</span> <span class="token operator">+</span> count <span class="token operator">+</span> <span class="token string">&quot;次！&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以看到代码中主要有两个变化：</p> <ol><li>取得剩余次数后马上更新-1后的次数。看似是避免了读取和更新间的时间间隔。</li> <li>更新剩余次数前先判断自己的更新次数是否为最新，避免更新后次数反而变大的问题。
这么修改后看起来好像没有问题了，那么我们再来试一下。</li></ol> <p>执行以下main方法：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Punishment</span> punishment <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Punishment</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token string">&quot;internationalization&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">Student</span> xiaoming <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">&quot;小明&quot;</span><span class="token punctuation">,</span>punishment<span class="token punctuation">)</span><span class="token punctuation">;</span>
    xiaoming<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">Student</span> xiaozhang <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">&quot;小张&quot;</span><span class="token punctuation">,</span>punishment<span class="token punctuation">)</span><span class="token punctuation">;</span>
    xiaozhang<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

     <span class="token class-name">Student</span> xiaozhao <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">&quot;小赵&quot;</span><span class="token punctuation">,</span>punishment<span class="token punctuation">)</span>
     xiaozhao<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>总数是100，问题解决了！等等，真的解决了吗？我们回过头再看改后的copyWord代码，虽然程序读取剩余次数后，马上更新，并且加了小于才更新的判断。但是仔细想想，这样并不是万全之策，因为小明和小张很可能恰巧同时去看剩余次数，取得剩余次数n后，各自计算剩余次数为n-1，但是假如小明正好计算的快一点，小明先把剩余次数更新为了n-1，虽然小张不符合更新条件，但是在剩余第n次的这次抄写上，小明和小张各抄写了一次，也就是说多抄写了一次。</p> <h3 id="_2-3-线程安全"><a href="#_2-3-线程安全" class="header-anchor">#</a> 2.3 线程安全</h3> <p>为什么上面代码打出的日志中，三人抄写总和是正确的100呢？有没有可能是抄写数量太小，全部抄写完也没有发生上面描述的两人同时去查看剩余次数的情况？为了验证这个推论，我们把抄写次数增多，看是否会出现问题。</p> <p>在我的电脑上，抄写数量加大到1000，三人抄写总和依然是正确的。但加大到10000时，问题出现了，有时会出现三人抄写次数大于10000的现象。我继续加大到1000000，此时基本每次执行，三人执行总和都要超出1-5次。以上实验结果，根据实验电脑的不同会有所区别。现在已经能够得出结论了，这样修改是不行的，原因前文已经说明，因为有小概率两人甚至三人同时查看剩余次数，导致重复抄写。</p> <p>以上所描述的问题，就是大家耳熟能详的线程安全问题。线程安全问题来源于并发时对共享资源的操作。在本例中，我们把剩余次数写在黑板上，大家都去黑板上读取剩余次数并更新。那么共享资源就是黑板上的剩余抄写次数。</p> <p>我们先不谈代码如何修改，我们来想一想现实生活中如何解决上述问题。</p> <p>问题出在小明读取剩余次数的同时，小张、小赵也可以读取，三人很可能读到同样的次数。并且读取完，三人都会根据自己的计算去更新剩余次数，所以才会乱了套。我们可以改为谁要读取次数时先做个标记（比如在次数边上写上自己名字），代表自己在操作，此时别人只能等待。详细流程如下图：</p> <p><img src="/assets/img/xiancheng2-3.3ecd75ca.jpg" alt="img"></p> <ol><li><p>读取剩余次数前，先看纸上是否有名字。没有名字，在纸上写上自己的名字；</p></li> <li><p>如果纸上已经有名字则等待，并且一直观察纸上名字是否被擦除；</p></li> <li><p>成功写上自己名字的同学，更新次数为n-1；</p></li> <li><p>擦掉自己的名字；</p></li> <li><p>其他等待者观察到名字被擦掉，则抢着写上自己的名字。</p></li></ol> <p>这样确保了同一时间只有一个人在操作剩余次数，再也不会乱套了。</p> <h3 id="_2-4-多线程相关概念"><a href="#_2-4-多线程相关概念" class="header-anchor">#</a> 2.4 多线程相关概念</h3> <p>以上流程引入了多线程中的一个重要概念–<strong>同步</strong>。所谓的同步就是某一段流程同时只能有一个线程执行，其它线程需要等待。对于本例，读取剩余次数，并更新剩余次数这两步操作需要做同步控制。操作剩余次数之前需要写名字代表自己在做操作，这是在<strong>加锁</strong>。而擦除名字则是释放锁。假如小明先成功写上自己的名字，而小张和小赵按照先来后到的顺序排队，那么就是<strong>公平锁</strong>。但假如两人并不排队，而是通过争抢获取写名字的权利，那么这就是<strong>非公平锁</strong>。在这种情况下，如果小张很瘦弱，既抢不过小赵，也抢不过小明，那么小张永远无法读取剩余次数，也就无法抄写单词，这种情况就叫做<strong>线程饿死</strong>。</p> <h2 id="_3-thread-vs-runnable"><a href="#_3-thread-vs-runnable" class="header-anchor">#</a> 3. Thread vs Runnable</h2> <p>多线程从根本上讲只有一种实现方式，就是实例化Thread，并且提供其执行的run方法。无论你是通过继承thread还是实现runnable接口，最终都是重写或者实现了run方法。而你真正启动线程都是通过实例化Thread，调用其start方法。我们看下前文中不同实现方式的例子：</p> <ol><li>thread</li></ol> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Student</span> xiaoming <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">&quot;小明&quot;</span><span class="token punctuation">,</span>punishment<span class="token punctuation">)</span><span class="token punctuation">;</span>
xiaoming<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ol start="2"><li>runnable</li></ol> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Thread</span> xiaoming <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">&quot;小明&quot;</span><span class="token punctuation">,</span>punishment<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">&quot;小明&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xiaoming<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>两种方式都是创建 Thread 或者 Thread 的子类，通过 Thread 的 start 方法启动。唯一不同是第一种 run 方法实现在 Thread 子类中。第二种则是把run方法逻辑转移到 Runnable 的实现类中。线程启动后，第一种方式是 thread 对象运行自己的 run 方法逻辑，第二种方式则是调用 Runnable 实现的 run 方法逻辑。如下图所示：</p> <p><img src="/assets/img/threadvsrunnable.3f4a99af.jpg" alt="img"></p> <p>相比较来说，第二种方式是更好的实践，原因如下：</p> <ol><li>java语言中只能单继承，通过实现接口的方式，可以让实现类去继承其它类。而直接继承thread就不能再继承其它类了；</li> <li>线程控制逻辑在Thread类中，业务运行逻辑在Runnable实现类中。解耦更为彻底；</li> <li>实现Runnable的实例，可以被多个线程共享并执行。而实现thread是做不到这一点的。</li></ol> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>看到这里，你是不是很好奇，为什么程序中调用的是Thread的start方法，而不是run方法？为什么线程在调用start方法后会执行run方法的逻辑呢？接下来我们通过开始start方法的源代码来找到答案。</p></div> <h3 id="_3-1-thread-start方法源代码分析"><a href="#_3-1-thread-start方法源代码分析" class="header-anchor">#</a> 3.1 Thread start方法源代码分析</h3> <p>我们先看Thread类start方法源代码，如下</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>threadStatus <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalThreadStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    group<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">boolean</span> started <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token function">start0</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        started <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>started<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                group<span class="token punctuation">.</span><span class="token function">threadStartFailed</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ignore<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>主要逻辑如下：</p> <ol><li>检查线程的状态，是否可以启动；</li> <li>把线程加入到线程group中；</li> <li>调用了start0()方法。</li></ol> <p>可以看到Start方法中最终调用的是start0方法，并不是run方法。那么我们再看start0方法源代码：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">start0</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>什么也没有，因为start0是一个native方法，也称为JNI（Java Native Interface）方法。JNI方法是java和其它语言交互的方式。同样也是java代码和虚拟机交互的方式，虚拟机就是由C++和汇编所编写。</p> <p>由于start0是一个native方法，所以后面的执行会进入到JVM中。那么run方法到底是何时被调用的呢？这里似乎找不到答案了。</p> <p>难道我们错过了什么？回过头来我们再看看Start方法的注解。其实读源代码的时候，要先读注解，否则直接进入代码逻辑，容易陷进去，出不来。原来答案就在start方法的注解里，我们可以看到：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token operator">*</span> <span class="token class-name">Causes</span> <span class="token keyword">this</span> thread <span class="token keyword">to</span> <span class="token namespace">begin</span> execution<span class="token punctuation">;</span> the <span class="token class-name">Java</span> <span class="token class-name">Virtual</span> <span class="token class-name">Machine</span>
<span class="token operator">*</span> calls the <span class="token generics"><span class="token punctuation">&lt;</span>code<span class="token punctuation">&gt;</span></span>run<span class="token operator">&lt;</span><span class="token operator">/</span>code<span class="token operator">&gt;</span> method of <span class="token keyword">this</span> thread<span class="token punctuation">.</span>
<span class="token operator">*</span> <span class="token generics"><span class="token punctuation">&lt;</span>p<span class="token punctuation">&gt;</span></span>
<span class="token operator">*</span> <span class="token class-name">The</span> result is that two threads are running concurrently<span class="token operator">:</span> the
<span class="token operator">*</span> current thread <span class="token punctuation">(</span>which returns from the call <span class="token keyword">to</span> <span class="token namespace">the</span>
<span class="token operator">*</span> <span class="token generics"><span class="token punctuation">&lt;</span>code<span class="token punctuation">&gt;</span></span>start<span class="token operator">&lt;</span><span class="token operator">/</span>code<span class="token operator">&gt;</span> method<span class="token punctuation">)</span> and the other thread <span class="token punctuation">(</span>which executes its
<span class="token operator">*</span> <span class="token generics"><span class="token punctuation">&lt;</span>code<span class="token punctuation">&gt;</span></span>run<span class="token operator">&lt;</span><span class="token operator">/</span>code<span class="token operator">&gt;</span> method<span class="token punctuation">)</span><span class="token punctuation">.</span>
<span class="token operator">*</span> <span class="token generics"><span class="token punctuation">&lt;</span>p<span class="token punctuation">&gt;</span></span>
<span class="token operator">*</span> <span class="token class-name">It</span> is never legal <span class="token keyword">to</span> <span class="token namespace">start</span> a thread more than once<span class="token punctuation">.</span>
<span class="token operator">*</span> <span class="token class-name">In</span> particular<span class="token punctuation">,</span> a thread may not be restarted once it has completed
<span class="token operator">*</span> execution<span class="token punctuation">.</span>
</code></pre></div><p>最关键一句*the Java Virtual Machine calls the run method of this thread。*由此我们可以推断出整个执行流程如下：</p> <p><code>start</code> ---&gt; <code>start0</code> ---&gt; <code>run</code></p> <p>start方法调用了start0方法，start0方法在JVM中，start0中的逻辑会调用run方法。</p> <p>至此，我们已经分析清楚从线程创建到run方法被执行的逻辑。但是通过实现Runnbale的方式实现多线程时，Runnable的run方法是如何被调用的呢？</p> <h2 id="_31-凭票取餐-future模式详解"><a href="#_31-凭票取餐-future模式详解" class="header-anchor">#</a> 31 凭票取餐—Future模式详解</h2> <p>我们先来看一个例子，假如你中午要出去买一份午餐打包带回家，并且要去超市买一管牙膏，应该怎么做才会时间最短？当然是点好外卖，然后去超市买牙膏，等你回来看外卖是否已经做好了，如果做好了，拿小票取餐。如果还没好，那就继续等待，等做好后取餐回家。</p> <p>如果程序不使用多线程实现的话，那么主线程就会阻塞在外卖加工过程上，直到午餐做好，才能去超市买东西。但如果我们采用多线程，可以点餐后马上去超市买牙膏，同时有新的线程加工你的午餐。今天我们来学习一种新的多线程应用模式 Future，解决起类似问题就容易多了。</p> <h3 id="_31-1-future-模式介绍"><a href="#_31-1-future-模式介绍" class="header-anchor">#</a> 31.1 Future 模式介绍</h3> <p>先来回顾下之前我们讲解的 Thread 和 runnable，实现多线程的方式是新起线程运行 run 方法，但是 run 方法有个缺陷是没有返回值，并且主线程也并不知道新的线程何时运行完毕。上文的例子，我们不但需要做饭的线程返回午餐，并且主线程需要知道午餐已经好了。使用我们之前学习知识，通过 wait、notify 和共享资源也可以实现，但会比较复杂。其实 JDK 提供了非常方便的工具就是 Future。Future 持有要运行的任务，以及任务的结果。主线程只要声明了 Future 对象，并且启动新的线程运行他。那么随时能通过 Future 对象获取另外线程运行的结果。</p> <p>接下来我们看看 Future 如何实现例子中的场景。</p> <h3 id="_31-2-future-使用"><a href="#_31-2-future-使用" class="header-anchor">#</a> 31.2 Future 使用</h3> <p>上述例子的代码如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        
      <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> cookTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token string">&quot;5斤的龙虾&quot;</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">Long</span> startTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;我点了5斤的龙虾。&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>cookTask<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;我去买牙膏。&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;我买到牙膏了！&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      
        <span class="token class-name">String</span> lunch <span class="token operator">=</span> cookTask<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;我点的&quot;</span><span class="token operator">+</span>lunch<span class="token operator">+</span><span class="token string">&quot;已经OK了！&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">Long</span> userTime <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> startTime<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">1000</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;我一共用了&quot;</span><span class="token operator">+</span>userTime<span class="token operator">+</span><span class="token string">&quot;秒买午餐并且买牙膏。&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>主线程运行后，先点了 5 斤的龙虾，然后一个新的线程就开始去执行 cookTask 了。等会儿，到这里你一定会问，Thread 构造方法需要传入 Runnable 的实现啊？没错，FutureTask 实现了 Runnable 接口。FutureTask 的 run 方法实际执行的是 Callable 的 call 方法。那么新的线程 start 后，实际做饭的逻辑会被执行：自线程 sleep3 秒后返回 “5 斤的龙虾”。</p> <p>主线程在启动做饭的自线程后继续向下执行，去买牙膏。这里 sleep 两秒，模拟买牙膏的时间消耗。</p> <p>买到牙膏接下来的一行代码 String lobster = cookTask.get (); 重点说一下，此时分两种情况：</p> <p>cookTask 运行的线程已经结束了，那么可以直接取到运行的结果赋值给 lunch；
cookTask 运行的线程还没有执行结束，此时主线程会阻塞，直到能取得运行结果。
cookTask 就是你的购物小票，只要你没弄丢，随时能去取你的午饭。</p> <p>程序最后计算了整个过程的执行时间。由于采用了多线程并发，所以执行时间应该等于耗时最长的那个任务。这个例子中做龙虾 3 秒 &gt; 买牙膏 2 秒，所以总共耗时 3 秒，输出如下：</p> <div class="language-java extra-class"><pre class="language-java"><code>我点了<span class="token number">5</span>斤的龙虾
我去买牙膏
我买到牙膏了！
我点的<span class="token number">5</span>斤的龙虾已经OK了
我一共用了<span class="token number">3</span>秒买午餐并且买牙膏
</code></pre></div><p>假如我调整买牙膏需要 10 秒，那么输出则如下：</p> <div class="language-java extra-class"><pre class="language-java"><code>我点了<span class="token number">5</span>斤的龙虾
我去买牙膏
我买到牙膏了！
我点的<span class="token number">5</span>斤的龙虾已经OK了
我一共用了<span class="token number">10</span>秒买午餐并且买牙膏
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>现在我们想一下，假如单线程串行执行，点完午餐必须等待午餐做好了，才能去买牙膏。那么永远耗时都是 2 者之和。采用并发执行后，仅为时间较长的那个任务的时间。</p> <p>由于我们调用 Future 的 get 方法后主线程就开始阻塞了，所以我们应该在真正需要使用 Future 对象的返回结果时才去调用，充分利用并发的特性来提升程序性能。</p></div> <h3 id="_31-3-future-源码解析"><a href="#_31-3-future-源码解析" class="header-anchor">#</a> 31.3 Future 源码解析</h3> <p>Future 是一个接口，而 FutrueTask 则是他的实现，我们看一下它们的继承关系：</p> <p><img src="/assets/img/Futureyuanma.91faf167.jpg" alt="img"></p> <p>FutureTask 不但实现了 Future 而且实现了 Runnable 接口。这也是为什么它能作为参数传入 Thread 构造方法。</p> <p>Runnable 接口我们讲过，里面只有一个 run 方法，用于被 Thread 调用。我们看一下 Future 接口有哪些方法：</p> <p><img src="/assets/img/Futurefangfa.e9cf3be1.jpg" alt="img"></p> <ul><li><p>cancel 用于尝试取消任务。</p></li> <li><p>get 用于等待并获取任务执行结果。带时间参数的 get 方法只会等待指定时间长度。</p></li> <li><p>isCancelled 返回任务在完成前是否已经被取消。</p></li> <li><p>isDone 返回任务是否完成。</p></li> <li><p>我们用到最多的就是 get 方法，获取任务的执行结果。</p></li></ul> <h4 id="_31-3-1-futuretask-构造方法"><a href="#_31-3-1-futuretask-构造方法" class="header-anchor">#</a> 31.3.1 FutureTask 构造方法</h4> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">FutureTask</span><span class="token punctuation">(</span><span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> callable<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>callable <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>callable <span class="token operator">=</span> callable<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> NEW<span class="token punctuation">;</span>       <span class="token comment">// ensure visibility of callable</span>
<span class="token punctuation">}</span>
</code></pre></div><p>需要传入 Callable 的实现，Callable 是一个接口，定义了 call 方法，返回 V 类型。</p> <p>然后定义了 FutureTask 的状态为 NEW。FutrueTask 定义了如下状态：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> NEW          <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> COMPLETING   <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> NORMAL       <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> EXCEPTIONAL  <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CANCELLED    <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> INTERRUPTING <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> INTERRUPTED  <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="_31-3-2-run-方法解析"><a href="#_31-3-2-run-方法解析" class="header-anchor">#</a> 31.3.2 run 方法解析</h4> <p>FutrueTask 实现了 Runnbale 接口，所以 Thread 运行后实际上执行的是 FutrueTask 的 run 方法。我们要想了解 Future 的实现原理，那么就应该从它的 run 方法开始入手。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//如果此时状态不为NEW直接结束</span>
  <span class="token comment">//如果为NEW，但是CAS操作把本线程写入为runner时，发现runner已经不为null，那么也直接结束</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>state <span class="token operator">!=</span> NEW <span class="token operator">||</span>
        <span class="token operator">!</span>UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> runnerOffset<span class="token punctuation">,</span>
                                     <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
      <span class="token comment">//取得Callable对象</span>
        <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> c <span class="token operator">=</span> callable<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> state <span class="token operator">==</span> NEW<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">V</span> result<span class="token punctuation">;</span>
            <span class="token keyword">boolean</span> ran<span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
              <span class="token comment">//运行Callable对象的call方法，并且取得返回值。</span>
                result <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                ran <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                result <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                ran <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                <span class="token function">setException</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
          <span class="token comment">//如果call方法成功执行结束，那么把执行结果设置给成员变量outcome;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>ran<span class="token punctuation">)</span>
                <span class="token function">set</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token comment">// runner must be non-null until state is settled to</span>
        <span class="token comment">// prevent concurrent calls to run()</span>
        runner <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token comment">// state must be re-read after nulling runner to prevent</span>
        <span class="token comment">// leaked interrupts</span>
        <span class="token keyword">int</span> s <span class="token operator">=</span> state<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">&gt;=</span> INTERRUPTING<span class="token punctuation">)</span>
            <span class="token function">handlePossibleCancellationInterrupt</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>核心逻辑就是执行运行 Callable 对象的 call 方法，把返回结果写入 outcome。outcome 用来保存计算结果。</p> <p>保存计算结果则是通过 set 方法。</p> <h4 id="_31-3-3-set-方法解析"><a href="#_31-3-3-set-方法解析" class="header-anchor">#</a> 31.3.3 set 方法解析</h4> <p>set 方法代码如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">V</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  	<span class="token comment">//状态还是NEW，保存计算结果给outcome</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> stateOffset<span class="token punctuation">,</span> NEW<span class="token punctuation">,</span> COMPLETING<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        outcome <span class="token operator">=</span> v<span class="token punctuation">;</span>
      <span class="token comment">//更新状态为NORMAL</span>
        UNSAFE<span class="token punctuation">.</span><span class="token function">putOrderedInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> stateOffset<span class="token punctuation">,</span> NORMAL<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// final state</span>
      <span class="token comment">//唤醒等待的线程</span>
        <span class="token function">finishCompletion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果没有被取消则会保存计算结果 v 到 outcome。然后更新最终状态为 NORMAL。最后调用 finishCompletion 方法唤醒阻塞的线程。代码如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">finishCompletion</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// assert state &gt; COMPLETING;</span>
  <span class="token comment">//遍历等待线程，结束等待</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">WaitNode</span> q<span class="token punctuation">;</span> <span class="token punctuation">(</span>q <span class="token operator">=</span> waiters<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> waitersOffset<span class="token punctuation">,</span> q<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
              <span class="token comment">//结束等待线程的挂起</span>
                <span class="token class-name">Thread</span> t <span class="token operator">=</span> q<span class="token punctuation">.</span>thread<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    q<span class="token punctuation">.</span>thread <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                    <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
              <span class="token comment">//如果没有下一个等待线程，那么结束循环</span>
                <span class="token class-name">WaitNode</span> next <span class="token operator">=</span> q<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                q<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// unlink to help gc</span>
                q <span class="token operator">=</span> next<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
		<span class="token comment">//全部完成后回调FutrueTask的done方法。done方法为空，可以由子类实现。</span>
    <span class="token function">done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//清除callable</span>
    callable <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token comment">// to reduce footprint</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="_31-3-4-get-方法解析"><a href="#_31-3-4-get-方法解析" class="header-anchor">#</a> 31.3.4 get 方法解析</h4> <p>get 方法用于获取任务的返回值，如果还没有执行完成，则会阻塞，代码如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">,</span> <span class="token class-name">ExecutionException</span> <span class="token punctuation">{</span>
    <span class="token comment">//获取当前Task的状态</span>
  	<span class="token keyword">int</span> s <span class="token operator">=</span> state<span class="token punctuation">;</span>
    <span class="token comment">//如果还没有完成，则阻塞等待完成</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">&lt;=</span> COMPLETING<span class="token punctuation">)</span>
        s <span class="token operator">=</span> <span class="token function">awaitDone</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token number">0L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  	<span class="token comment">//获取任务执行的返回结果</span>
    <span class="token keyword">return</span> <span class="token function">report</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们先来看 awaitDone 的代码：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">awaitDone</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> timed<span class="token punctuation">,</span> <span class="token keyword">long</span> nanos<span class="token punctuation">)</span>
    <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
  <span class="token comment">//计算等待截止时长</span>
    <span class="token keyword">final</span> <span class="token keyword">long</span> deadline <span class="token operator">=</span> timed <span class="token operator">?</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> nanos <span class="token operator">:</span> <span class="token number">0L</span><span class="token punctuation">;</span>
    <span class="token class-name">WaitNode</span> q <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">boolean</span> queued <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">//当前线程如果被打断，则不再等待。从等待链表中移除</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">removeWaiter</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
			<span class="token comment">//取得目前的状态</span>
        <span class="token keyword">int</span> s <span class="token operator">=</span> state<span class="token punctuation">;</span>
      <span class="token comment">//如果已经执行完成，清空q节点保存的线程</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">&gt;</span> COMPLETING<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>q <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                q<span class="token punctuation">.</span>thread <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> s<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token comment">//如果正在执行，让出CPU执行权</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> COMPLETING<span class="token punctuation">)</span> <span class="token comment">// cannot time out yet</span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token keyword">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">//没有进入以上分支，运行到此分支，这说明此线程确实需要开始等待了，</span>
      <span class="token comment">//那么如果还未为此线程建立关联的等待节点，则进行创建。</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>q <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            q <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WaitNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">//通过CAS把此线程的等待node加入到连表中。失败的话，下次循环若能运行到此分支，会继续添加。</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>queued<span class="token punctuation">)</span>
            queued <span class="token operator">=</span> UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> waitersOffset<span class="token punctuation">,</span>
                                                 q<span class="token punctuation">.</span>next <span class="token operator">=</span> waiters<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">//如果设置了超时，检查是否超时。超时的话结束等待。 否则挂起超时时长</span>
      <span class="token comment">//如果没有设置超时时长，则永久挂起</span>
      <span class="token comment">//回到上面的finishCompletion方法，等到task执行完成后会执行LockSupport.unpark(t)，结束阻塞。</span>
      <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>timed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            nanos <span class="token operator">=</span> deadline <span class="token operator">-</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">&lt;=</span> <span class="token number">0L</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">removeWaiter</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> state<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">parkNanos</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> nanos<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span>
            <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>最后我们看一下 report 方法：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token class-name">V</span> <span class="token function">report</span><span class="token punctuation">(</span><span class="token keyword">int</span> s<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ExecutionException</span> <span class="token punctuation">{</span>
  <span class="token comment">//获取执行结果</span>
    <span class="token class-name">Object</span> x <span class="token operator">=</span> outcome<span class="token punctuation">;</span>
  <span class="token comment">//NORMAL为正常结束，那么直接把X转型后返回</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> NORMAL<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">V</span><span class="token punctuation">)</span>x<span class="token punctuation">;</span>
  <span class="token comment">//如果任务被取消了，则抛出异常</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">&gt;=</span> CANCELLED<span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">CancellationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Throwable</span><span class="token punctuation">)</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>outcome 保存的就是任务的执行结果。根据此时的状态，选择返回执行结果还是抛出取消的异常。</p> <p>最后我们总结下 FutureTask 的代码：</p> <ol><li><p>FutureTask 实现 Runnable 和 Future 接口；</p></li> <li><p>在线程上运行 FutureTask 后，run 方法被调用，run 方法会调用传入的 Callable 接口的 call 方法；</p></li> <li><p>拿到返回值后，通过 set 方法保存结果到 outcome，并且唤醒所有等待的线程；</p></li> <li><p>调用 get 方法获取执行结果时，如果没有执行完毕，则进入等待，直到 set 方法调用后被唤醒。</p></li></ol> <p>下图示意了两个线程运行 task 和 get 时的程序逻辑：</p> <p><img src="/assets/img/futureTask.e90b48af.jpg" alt="img"></p> <h4 id="_31-4-总结"><a href="#_31-4-总结" class="header-anchor">#</a> 31.4 总结</h4> <p>Future 模式在实际开发中有着大量的应用场景。比如说微服务架构中，需要调用不同服务接口获取数据，但是接口调用间并无依赖关系，那么可以通过 FutureTask 并发调用，然后再执行后续逻辑。如果我们采用串行的方式，则需要一个接口返回后，再调用下一个接口。FutreTask 需要结合 Callable 接口使用，示例代码中为了让大家显示的看到 Callable 接口，所以采用匿名对象的方式。实际使用中我们可以使用 lambda 表达式来简化代码，如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> cookTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token string">&quot;5斤的龙虾&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="_34-completablefuture"><a href="#_34-completablefuture" class="header-anchor">#</a> 34 CompletableFuture</h2> <h3 id="_34-1-completablefuture-起源"><a href="#_34-1-completablefuture-起源" class="header-anchor">#</a> 34.1 CompletableFuture 起源</h3> <p>CompletableFuture 作为 Java 8 的新特性被引入。任何工具的出现肯定带着自己的使命，那么它是用来解决什么问题的呢？</p> <p>在现实世界中，我们需要解决的复杂问题都是要分为若干步骤。就像我们的代码一样，一个复杂的逻辑方法中，会调用多个方法来一步一步实现。</p> <p>设想如下场景，植树节要进行植树，分为下面几个步骤：</p> <ol><li><p>挖坑 10 分钟</p></li> <li><p>拿树苗 5 分钟</p></li> <li><p>种树苗 20 分钟</p></li> <li><p>浇水 5 分钟</p></li></ol> <p>其中 1 和 2 可以并行，1 和 2 都完成了才能进行步骤 3，然后才能进行步骤 4。</p> <p>我们有如下几种实现方式：</p> <p><strong>1、只有一个人种树</strong></p> <p>如果现在只有一个人植树，要种 100 棵树，那么只能按照如下顺序执行：
可以看到串行执行，只能种完一棵树再种一棵，那么种完 100 棵树需要 40 * 100 = 4000 分钟。
这种方式对应到程序，就是单线程同步执行。</p> <p><strong>2、三个人同时种树，每个人负责种一棵树</strong></p> <p>如何缩短种树时长呢？你肯定想这还不好办，学习了这么久的并发，这肯定难不倒我。不是要种 100 棵树吗？那我找 100 个人一块种，每个人种一棵。那么只需要 40 分钟就可以种完 100 棵树了。</p> <p>没错，如果你的程序有个方法叫做 plantTree，里面包含了如上四部，那么你起 100 个线程就可以了。但是，请注意，100 个线程的创建和销毁需要消耗大量的系统资源。并且创建和销毁线程都有时间消耗。此外CPU的核数并不能真的支持100个线程并发。如果我们要种1万棵树呢？总不能起一万个线程吧？</p> <p>所以这只是理想情况，我们一般是通过线程池来执行，并不会真的启动100个线程。</p> <p><strong>3、多个人同时种树。种每一棵树的时候，不依赖的步骤可以分不同的人并行干</strong></p> <p>这种方式可以进一步缩短种树的时长，因为第一步挖坑和第二步拿树苗可以两个人并行去做，所以每棵树只需要35 分钟。如下图：</p> <p><img src="/assets/img/plantTree.26991523.jpg" alt="img"></p> <p>如果程序还是 100 个主线程并发运行 plantTree 方法，那么只需要 35 分钟种完 100 颗树。</p> <p>这里需要注意每个线程中，由于还要并发两个线程去做 1，2 两个步骤。实际运行中会又 100*3 = 300 个线程参与植树。但是负责 1，2 步骤的线程只会短暂参与，然后就闲置了。</p> <p>这种方法和第二种方式也存在大量创建线程的问题。所以也只是理想情况。</p> <p><strong>4、假如只有 4 个人植树，每个人只负责自己的步骤，那么执行如下图</strong></p> <p><img src="/assets/img/plantTree2.6d8c5deb.jpg" alt="img"></p> <p>可以看到一开始小王挖完第一个坑后，小李已经取回两个树苗，但此时小张才能开始种第一个树苗。此后小张就可以一个接一个的去种树苗了，并且在他种下一棵树苗的时候，小赵可以并行浇水。按照这个流程走下来，种完 100 颗树苗需要 10+20x100+5=2015 分钟。比单线程的4000分钟好了很多，但是远远比不上 100 个线程并发种树的速度。不过不要忘记 100 个线程并发只是理想情况，而本方法只用了 4 个线程。</p> <p>我们再对分工做下调整。每个人不只干自己的工作，一旦自己的工作做完了就看有没有其他工作可以做。比如小王挖坑完后，发现可以种树苗，那么他就去种树苗。小李拿树苗完成后也可以去挖坑或者种树苗。这样整体的效率就会更高了。如果基于这种思想，那么我们实际上把任务分成了 4 类，每类 100 件，一共 400 件任务。400 件任务全部完成，意味着整个任务就完成了。那么任务的参与者只需要知道任务的依赖，然后不断领取可以执行的任务去执行。这样的效率将会是最高的。</p> <p>前文说到我们不可能通过100个线程并发来执行任务，所以一般情况下我们都会使用线程池，这和上面的设计思想不谋而合。使用线程池后，由于第四种方式把步骤拆的更细，提高了并发的可能性。因此速度会比第二种方式更快。那么和第三种比起来，哪种更快呢？如果线程数量可以无穷大，这两个方法能达到的最短时间是一样的，都是 35 分钟。不过在线程有限的情况下，第四种方式对线程的使用率会更高，因为每个步骤都可以并行执行（参与种树的人完成自己的工作后，都可以去帮助其他人），线程的调度更为灵活，所以线程池中的线程很难闲下来，一直保持在运转之中。是的，谁都不能偷懒。而第三种由于只能并发在 plantTree 方法及挖坑和拿树苗，所以不如第四种方式灵活。</p> <p>上文讲了这么多，主要是要说明 CompletableFuture 出现的原因。他用来把复杂任务拆解为一个个衔接的异步执行步骤，从而提升整体的效率。我们回一下小节题目：<code>谁都不能偷懒</code>。没错，这就是 CompletableFuture 要达到的效果，通过对计算单元的抽象，让线程能够高效的并发参与每一个步骤。同步的代码通过 CompletableFuture 可以完全改造为异步代码。下面我们就来看看如何使用 CompletableFuture。</p> <h3 id="_34-2-completablefuture-介绍"><a href="#_34-2-completablefuture-介绍" class="header-anchor">#</a> 34.2 CompletableFuture 介绍</h3> <p>CompletableFuture 实现了 Future 接口并且实现了 CompletionStage 接口。Future 接口我们已经很熟悉了，而CompletionStage 接口定了异步计算步骤之间的规范，这样确保一步一步能够衔接上。CompletionStage 定义了38 个 public 的方法用于异步计算步骤间的衔接。接下来我们会挑选一些常用的，相对使用频率较高的方法，来看看如何使用。</p> <h4 id="_34-2-1-已知计算结果"><a href="#_34-2-1-已知计算结果" class="header-anchor">#</a> 34.2.1 已知计算结果</h4> <p>如果你已经知道 CompletableFuture 的计算结果，可以使用静态方法 completedFuture。传入计算结果，声明CompletableFuture 对象。在调用 get 方法时会立即返回传入的计算结果，不会被阻塞，如下代码：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">noComputation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
    <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> completableFuture
            <span class="token operator">=</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">completedFuture</span><span class="token punctuation">(</span><span class="token string">&quot;hello world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;result is &quot;</span> <span class="token operator">+</span> completableFuture<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
    <span class="token function">noComputation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>输出为：</p> <p><code>result is hello world</code></p> <p>是不是觉得这种用法没有什么意义？既然知道计算结果了，直接使用就好了，为什么还要通过 CompletableFuture 进行包装？这是因为异步计算单元需要通过 CompletableFuture 进行衔接，所以有的时候我们即使已经知道计算结果，也需要包装为 CompletableFuture，才能融入到异步计算的流程之中。</p> <h4 id="_34-2-2-封装有返回值的异步计算逻辑"><a href="#_34-2-2-封装有返回值的异步计算逻辑" class="header-anchor">#</a> 34.2.2 封装有返回值的异步计算逻辑</h4> <p>这是我们最常用的方式。把需要异步计算的逻辑封装为一个计算单元，交由 CompletableFuture 去运行。如下面的代码：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
    <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> completableFuture
            <span class="token operator">=</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token string">&quot;挖坑完成&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;result is &quot;</span> <span class="token operator">+</span> completableFuture<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
    <span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里我们使用了 CompletableFuture 的 supplyAsync 方法，以 lambda 表达式的方式向其传递了一个 supplier 接口的实现。supplier 是只有一个方法的函数接口，这里使用的就是常说的函数式编程。关于函数式编程并不在本专栏讨论范围内，这里你只需要知道我们为 supplyAsync 方法传入了一个可执行的函数，而 “Hello world” 就是这段函数的返回值。我们运行后结果如下：</p> <p><code>result is 挖坑完成</code></p> <p>可见 completableFuture.get() 拿到的计算结果就是你传入函数执行后 return 的值。那么如果你有需要异步计算的逻辑，那么就可以放到 supplyAsync 传入的函数体中。这段函数是如何被异步执行的呢？如果你跟入代码可以看到其实 supplyAsync 是通过 Executor，也就是线程池来运行这段函数的。completableFuture 默认使用的是ForkJoinPool，当然你也可以通过为 supplyAsync 指定其他 Excutor，通过第二个参数传入 supplyAsync 方法。</p> <p>supplyAsync 使用场景非常多，举个简单的例子，主程序需要调用多个微服务的接口请求数据，那么就可以启动多个 CompletableFuture，调用 supplyAsync，函数体中是关于不同接口的调用逻辑。这样不同的接口请求就可以异步同时运行，最后再等全部接口返回时，执行后面的逻辑.</p> <h4 id="_34-2-3-封装无返回值的异步计算逻辑"><a href="#_34-2-3-封装无返回值的异步计算逻辑" class="header-anchor">#</a> 34.2.3 封装无返回值的异步计算逻辑</h4> <p>supplyAsync 接收的函数是有返回值的。有些情况我们只是一段计算过程，并不需要返回值。这就像 Runnable 的run 方法，并没有返回值。这种情况我们可以使用 runAsync方法，如下面的代码：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">runAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
    <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span> completableFuture
            <span class="token operator">=</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">runAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;挖坑完成&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

   completableFuture<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
    <span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>runAsync 接收 runnable 接口的函数。所以并无返回值。栗子中的逻辑只是打印“挖坑完成”。</p> <h4 id="_34-2-4-进一步处理异步返回的结果-并返回新的计算结果"><a href="#_34-2-4-进一步处理异步返回的结果-并返回新的计算结果" class="header-anchor">#</a> 34.2.4 进一步处理异步返回的结果，并返回新的计算结果</h4> <p>当我们通过 supplyAsync 完成了异步计算，返回 CompletableFuture，此时可以继续对返回结果进行加工，如下面的代码：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">thenApply</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
    <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> completableFuture
            <span class="token operator">=</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token string">&quot;挖坑完成&quot;</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">thenApply</span><span class="token punctuation">(</span>s<span class="token operator">-&gt;</span>s<span class="token operator">+</span><span class="token string">&quot;,并且归还铁锹&quot;</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">thenApply</span><span class="token punctuation">(</span>s<span class="token operator">-&gt;</span>s<span class="token operator">+</span><span class="token string">&quot;，全部完成。&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;result is &quot;</span> <span class="token operator">+</span> completableFuture<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
    <span class="token function">thenApply</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在调用 supplyAsync 后，我们两次链式调用 thenApply 方法。s 是前一步 supplyAsync 返回的计算结结果，我们对结算结果进行了两次再加工，输出如下：</p> <div class="language-java extra-class"><pre class="language-java"><code>result is 挖坑完成<span class="token punctuation">,</span>并且归还铁锹，全部完成。
</code></pre></div><p>我们可以通过 thenApply 不断对计算结果进行加工处理。</p> <p>如果想异步运行 thenApply 的逻辑，可以使用 thenApplyAsync。使用方法 xiangtong1，只不过会通过线程池异步运行.</p> <h4 id="_34-2-5-进一步处理异步返回的结果-无返回"><a href="#_34-2-5-进一步处理异步返回的结果-无返回" class="header-anchor">#</a> 34.2.5 进一步处理异步返回的结果，无返回</h4> <p>这种场景你可以使用 <code>thenApply</code> 。这个方法可以让你处理上一步的返回结果，但无返回值。参照如下代码：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">thenAccept</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
    <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span> completableFuture
            <span class="token operator">=</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token string">&quot;挖坑完成&quot;</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">thenAccept</span><span class="token punctuation">(</span>s<span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token operator">+</span><span class="token string">&quot;,并且归还铁锹&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    completableFuture<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
    <span class="token function">thenAccept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里可以看到 thenAccept 接收的函数没有返回值，只有业务逻辑。处理后返回 CompletableFuture 类型对象。</p> <h4 id="_34-2-6-进一步处理异步返回的结果-并返回新的计算结果"><a href="#_34-2-6-进一步处理异步返回的结果-并返回新的计算结果" class="header-anchor">#</a> 34.2.6 进一步处理异步返回的结果，并返回新的计算结果</h4> <p>此时你可以使用 <code>thenRun</code> 方法，他接收 Runnable 的函数，没有输入也没有输出，仅仅是在异步计算结束后回调一段逻辑，比如记录 log 等。参照下面代码：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">thenRun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
    <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span> completableFuture
            <span class="token operator">=</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token string">&quot;挖坑完成&quot;</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">thenAccept</span><span class="token punctuation">(</span>s<span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token operator">+</span><span class="token string">&quot;,并且归还铁锹&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">thenRun</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;挖坑工作已经全部完成&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    completableFuture<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
    <span class="token function">thenRun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="_34-2-7-进一步处理异步返回的结果-并返回新的计算结果"><a href="#_34-2-7-进一步处理异步返回的结果-并返回新的计算结果" class="header-anchor">#</a> 34.2.7 进一步处理异步返回的结果，并返回新的计算结果</h4></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/back-end/Java/Java8.html" class="prev">
        Java8
      </a></span> <span class="next"><a href="/back-end/Java/String.html">
        String
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.36d4b3ff.js" defer></script><script src="/assets/js/2.ac6f8352.js" defer></script><script src="/assets/js/3.81c00a93.js" defer></script>
  </body>
</html>
